%%%% Copyright (C) 2005 -- 2013, Christopher Mark Gore,
%%%% Soli Deo Gloria,
%%%% All rights reserved.
%%%%
%%%% 8729 Lower Marine Road, Saint Jacob, Illinois 62281 USA.
%%%% Web: http://cgore.com
%%%% Email: cgore@cgore.com
%%%%
%%%% Redistribution and use in source and binary forms, with or without
%%%% modification, are permitted provided that the following conditions are met:
%%%%
%%%%     * Redistributions of source code must retain the above copyright
%%%%       notice, this list of conditions and the following disclaimer.
%%%%
%%%%     * Redistributions in binary form must reproduce the above copyright
%%%%       notice, this list of conditions and the following disclaimer in the
%%%%       documentation and/or other materials provided with the distribution.
%%%%
%%%%     * Neither the name of Christopher Mark Gore nor the names of other
%%%%       contributors may be used to endorse or promote products derived from
%%%%       this software without specific prior written permission.
%%%%
%%%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%%%% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%%%% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%%%% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%%%% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%%%% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%%%% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%%%% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%%%% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%%%% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%%%% POSSIBILITY OF SUCH DAMAGE.

\lispPackageChapter{Behave}

The \texttt{behave} package contains some useful code for confirming behavior of
code, supporting a very basic form of \textit{behavior-driven development}, BDD.
The basic flow is to define the \textit{behavior} of something, with multiple
\textit{specs} specified within that behavior specification, each consisting of
various assertions, such as \texttt{should=}, \texttt{should-equal},
\texttt{should-not-equal}, and many others.  If the behavior of the thing
doesn't match the specified behavior, then there is some error.

\section{Macros}

\lispMacroSubsection{Behavior}

The \texttt{behavior} macro is used to specify a block of expected behavior for
a \texttt{thing}.  It specifies an example group, loosly similar to the
\texttt{describe} blocks in Ruby's RSpec.  It takes a single argument, the
\texttt{thing} we are trying to describe, and then a body of code to evaluate
that is evaluated in an implicit \texttt{progn}.  It is to be used around a set
of examples, or around a set of assertions directly.

\lispSyntax

\texttt{(behavior \lispVar{thing} \&body \lispVar{body})}

\lispExamples

\begin{verbatim}
(behavior 'float
          (spec "is an Abelian group"
                (let ((a (random 10.0))
                      (b (random 10.0))
                      (c (random 10.0))
                      (e 1.0))
                  (spec "closure"
                        (should-be-a 'float (* a b)))
                  (spec "associativity"
                        (should= (* (* a b) c)
                                 (* a (* b c))))
                  (spec "identity element"
                        (should= a (* e a)))
                  (spec "inverse element"
                        (let ((1/a (/ 1 a)))
                          (should= (* 1/a a)
                                   (* a 1/a)
                                   1.0)))
                  (spec "commutitativity"
                        (should= (* a b) (* b a))))))
\end{verbatim}

\lispMacroSubsection{Spec}

The \texttt{spec} macro is used to indicate a specification for a desired
behavior.  It will normally serve as a grouping for assertions or nested
\texttt{spec}s.

\lispSyntax

\texttt{(spec \lispVar{description} \&body \lispVar{body})}

\lispExamples

\begin{verbatim}
(spec "should pass some tests"
      (should= 12 (foo 3.5))
      (should= 14 (foo 4.22)))
\end{verbatim}


\lispMacroSubsection{Should}

The \texttt{should} macro is the basic building block for most of the behavior
checking.  It asserts that \texttt{test} returns truthfully for the arguments.
Typically you will want to use one of the macros defined on top of
\texttt{should} instead of using it directly, such as \texttt{should=}.

\lispSyntax

\texttt{(should \lispVar{test} \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should #'= 12 (* 3 4))
(should #'< 4 (* 2 3))
(should #'< 4 5 6 7)
\end{verbatim}

\lispMacroSubsection{Should-Not}

The \texttt{should-not} macro is identical to the \texttt{should} macro, except
that it inverts the result of the call with \texttt{not}.

\lispSyntax

\texttt{(should-not \lispVar{test} \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should-not #'< 12 4) ; Passes
(should-not #'= 12 44) ; Passes
\end{verbatim}

\lispMacroSubsection{Should-Be-Null}

The \texttt{should-be-null} macro is a short-hand method for
 \texttt{(should \#'null \ldots)}.

\lispSyntax

\texttt{(should-be-null \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should-be-null ())
(should-be-null nil)
(should-be-null (not 12))
(should-be-null (and t t nil))
\end{verbatim}

\lispMacroSubsection{Should-Be-True}

The \texttt{should-be-true} macro is a short-hand method for
\texttt{(should \#'identity \ldots)}.

\lispSyntax

\texttt{(should-be-true \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should-be-true t)
(should-be-true (not nil))
(should-be-true (or nil nil 12))
\end{verbatim}

\lispMacroSubsection{Should-Be-False}

The \texttt{should-be-false} macro is a short-hand method for
\texttt{(should \#'not \ldots)}.

\lispSyntax

\texttt{(should-be-false \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should-be-false nil)
(should-be-false (not t))
(should-be-false (< 44 2))
\end{verbatim}

\lispMacroSubsection{Should-Be-A}

The \texttt{should-be-a} macro specifies that one or more \texttt{things} should
be of the type specified by \texttt{type}.

\begin{verbatim}
(should-be-a 'integer 1) ; passes
(should-be-a 'float 1) ; passes
(should-be-a 'integer 1 2 3 4 5 6 7 8 9) ; passes
(should-be-a 'integer 1.0) ; fails
\end{verbatim}

\lispMacroSubsection{Should=}

The \texttt{should=} macro is a short-hand method for
\texttt{(should \#'= \ldots)}.

\lispSyntax

\texttt{(should= \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should= 12 12)
(should= 12 12.0) ; Passes
\end{verbatim}

\lispMacroSubsection{Should/=}

The \texttt{should/=} macro is a short-hand method for
\texttt{(should \#'/= \ldots)}.

\lispSyntax

\texttt{(should= \&rest \lispVar{arguments})}

\lispExamples

\begin{verbatim}
(should/= 12 13) ; Passes
(should/= 12 12) ; Fails
(should/= 12 12.0) ; Fails
\end{verbatim}

\lispMacroSubsection{Should<}

\lispMacroSubsection{Should>}

\lispMacroSubsection{Should<=}

\lispMacroSubsection{Should>=}

\lispMacroSubsection{Should-Eq}

\lispMacroSubsection{Should-Not-Eq}

\lispMacroSubsection{Should-Eql}

\lispMacroSubsection{Should-Not-Eql}

\lispMacroSubsection{Should-Equal}

\lispMacroSubsection{Should-Not-Equal}

\lispMacroSubsection{Should-EqualP}

\lispMacroSubsection{Should-Not-EqualP}

\lispMacroSubsection{Should-String=}

\lispMacroSubsection{Should-Not-String=}

\lispMacroSubsection{Should-String/=}

\lispMacroSubsection{Should-Not-String/=}

\lispMacroSubsection{Should-String<}

\lispMacroSubsection{Should-Not-String<}

\lispMacroSubsection{Should-String>}

\lispMacroSubsection{Should-Not-String>}

\lispMacroSubsection{Should-String<=}

\lispMacroSubsection{Should-Not-String<=}

\lispMacroSubsection{Should-String>=}

\lispMacroSubsection{Should-Not-String>=}

\lispMacroSubsection{Should-String-Equal}

\lispMacroSubsection{Should-Not-String-Equal}

\lispMacroSubsection{Should-String-Not-Equal}

\lispMacroSubsection{Should-Not-String-Not-Equal}

\lispMacroSubsection{Should-String-LessP}

\lispMacroSubsection{Should-Not-String-LessP}

\lispMacroSubsection{Should-String-GreaterP}

\lispMacroSubsection{Should-Not-String-GreaterP}

\lispMacroSubsection{Should-String-Not-GreaterP}

\lispMacroSubsection{Should-Not-String-Not-GreaterP}

\lispMacroSubsection{Should-String-Not-LessP}

\lispMacroSubsection{Should-Not-String-Not-LessP}
