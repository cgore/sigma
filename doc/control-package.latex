%%%% Copyright (C) 2005 -- 2013, Christopher Mark Gore,
%%%% Soli Deo Gloria,
%%%% All rights reserved.
%%%%
%%%% 8729 Lower Marine Road, Saint Jacob, Illinois 62281 USA.
%%%% Web: http://cgore.com
%%%% Email: cgore@cgore.com
%%%%
%%%% Redistribution and use in source and binary forms, with or without
%%%% modification, are permitted provided that the following conditions are met:
%%%%
%%%%     * Redistributions of source code must retain the above copyright
%%%%       notice, this list of conditions and the following disclaimer.
%%%%
%%%%     * Redistributions in binary form must reproduce the above copyright
%%%%       notice, this list of conditions and the following disclaimer in the
%%%%       documentation and/or other materials provided with the distribution.
%%%%
%%%%     * Neither the name of Christopher Mark Gore nor the names of other
%%%%       contributors may be used to endorse or promote products derived from
%%%%       this software without specific prior written permission.
%%%%
%%%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%%%% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%%%% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%%%% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%%%% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%%%% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%%%% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%%%% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%%%% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%%%% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%%%% POSSIBILITY OF SUCH DAMAGE.

\lispPackageChapter{Sigma/Control}

The \texttt{sigma/control} package contains code for basic program control
systems.  These are mostly basic macros to add more complicated looping,
conditionals, or similar.  These are typically extensions to Common Lisp that
are inspired by other programming languages.  Thanks to the power of Common Lisp
and its macro system, we can typically implement most features of any other
language with little trouble.

\section{Macros}

\lispMacroSubsection{AIf}

The \texttt{aif} macro is an anaphoric variation of the built-in \texttt{if}
control structure.  This is based on \cite[p.~190]{on-lisp}.  The basic idea is
to provide an anaphor (such as pronouns in English) for the conditional so that
it can easily be referred to within the body of the conditional expression.  The
most natural pronoun in the English language for a thing is ``it'', so that is
what is used.  If you need or want to use a different anaphor, use
\texttt{a?if}.  The most common use of \texttt{aif} is for when you want to do
some additional computation with some time-consuming calculation, but only if it
returned successfully.

\lispSyntax

\texttt{(aif \lispVar{conditional} \lispVar{t-action} \&optional \lispVar{nil-action})}

\lispExamples

\begin{verbatim}
(aif (big-long-calculation)
     (foo it)
     (format t "The big-long-calculation failed!~%"))
\end{verbatim}

This is similar to the following, but with less typing:

\begin{verbatim}
(let ((it (big-long-calculation)))
  (if it
      (foo it)
      (format t "The big-long-calculation failed!~%")))
\end{verbatim}

\lispMacroSubsection{A?If}

The \texttt{a?if} macro is a variation of \texttt{aif} that allows for the
specification of the anaphor to use, instead of being restricted to just
\texttt{it}, the fefault with \texttt{aif}.  This is most often useful when you
need to nest calls to anaphoric macros.

\lispSyntax

\texttt{(a?if \lispVar{anaphor} \lispVar{conditional} \lispVar{t-action} \&optional \lispVar{nil-action})}

\lispExamples

\begin{verbatim}
(a?if foo 'outer
  (a?if bar 'inner
    `(,foo ,bar))) ; Returns '(outer inner)
\end{verbatim}

\lispMacroSubsection{AAnd}

The \texttt{aand} macro is an anaphoric variation of the built-in \texttt{and}.
This is based on \cite[p.~191]{on-lisp}.  It works in a similar manner to
\texttt{aif}, defining \texttt{it} as the current argument for use in the next
argument, reassigning \texttt{it} with each argument.

\lispSyntax

\texttt{(aand \&rest arguments)}

\lispExamples

\begin{verbatim}
(aand 2         ; Sets 'it' to 2.
      (* 3 it)  ; Sets 'it' to 6.
      (* 4 it)) ; Returns 24.
\end{verbatim}

\lispMacroSubsection{A?And}

The \texttt{a?and} macro is a variant of \texttt{aand} that allows for the
specification of the anaphor to use, instead of being restricted to just
\texttt{it}, the default with \texttt{aand}.  This is most often useful when you
need to nest calls to anaphoric macros.

\lispExamples

\begin{verbatim}
(a?and foo 12 (* 2 foo) (* 3 foo)) ; Returns 72.

(a?and foo 1 2 3 'outer
  (a?and bar 4 5 6 'inner `(,foo ,bar))) ; Returns '(outer inner)
\end{verbatim}

\lispMacroSubsection{ALambda}

The \texttt{alambda} macro is an anaphoric variant of the built-in
\texttt{lambda}.  This is based on \cite[p.~193]{on-lisp}.  It works in a
similar manner to \texttt{aif} and \texttt{aand}, except it defines
\texttt{self} instead of \texttt{it} as the default anaphor.  This is useful so
that you can write recursive lambdas.


\begin{verbatim}
(funcall (alambda (x) ; Simple recursive factorial example.
           (if (<= x 0)
               1
               (* x (self (1- x)))))
         10))) ; Calculates 10!, inefficently.
\end{verbatim}

\lispMacroSubsection{A?Lambda}


The \texttt{a?lambda} macro is an variant of \texttt{alambda} that allows you to
specify the anaphor to use.

\begin{verbatim}
(funcall (a?lambda ! (x) ; Simple recursive factorial example.
           (if (<= x 0)
               1
               (* x (! (1- x)))))
         10))) ; Calculates 10!, inefficently.
\end{verbatim}

\lispMacroSubsection{ABlock}

\lispMacroSubsection{A?Block}

\lispMacroSubsection{ACond}

\lispMacroSubsection{A?Cond}

\lispMacroSubsection{AWhen}

\lispMacroSubsection{A?When}

\lispMacroSubsection{AWhile}

\lispMacroSubsection{A?While}

\lispMacroSubsection{DeleteF}

\lispMacroSubsection{Do-While}

\lispMacroSubsection{Do-Until}

\lispMacroSubsection{For}

\lispMacroSubsection{Forever}

\lispMacroSubsection{Multicond}

\lispMacroSubsection{OpF}

\lispMacroSubsection{Swap}

\lispMacroSubsection{Swap-Unless}

\lispMacroSubsection{Swap-When}

\lispMacroSubsection{Until}

\lispMacroSubsection{While}

\section{Functions}

\lispFunctionSubsection{Compose}

\lispFunctionSubsection{Conjoin}

\lispFunctionSubsection{Curry}

\lispFunctionSubsection{Disjoin}

\lispFunctionSubsection{Function-Alias}

\lispFunctionSubsection{Operator-To-Function}

\lispFunctionSubsection{RCompose}

\lispFunctionSubsection{RCurry}

\lispFunctionSubsection{Unimplemented}

\section{Generics}

\lispGenericSubsection{Duplicate}
